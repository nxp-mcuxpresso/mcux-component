#!/usr/bin/env python3
#
# Copyright (c) 2017 Intel Corporation
# Copyright 2022, 2024 NXP
#
# SPDX-License-Identifier: Apache-2.0

# Generates z_impl wrapper invocations for NXP generic HAL
# Based on gen_syscalls.py

import argparse
import os
import re
import json

syscall_template = """/* auto-generated by gen_sdk_syscalls.py, don't edit */

{include_guard}

#ifdef __cplusplus
extern "C" {{
#endif

{invocations}

#ifdef __cplusplus
}}
#endif

#endif /* include guard */
"""

typename_regex = re.compile(r'(.*?)([A-Za-z0-9_]+)$')

class SyscallParseException(Exception):
    pass


def typename_split(item):
    if "[" in item:
        raise SyscallParseException(
            "Please pass arrays to syscalls as pointers, unable to process '%s'" %
            item)

    if "(" in item:
        raise SyscallParseException(
            "Please use typedefs for function pointers")

    mo = typename_regex.match(item)
    if not mo:
        raise SyscallParseException("Malformed system call invocation")

    m = mo.groups()
    return (m[0].strip(), m[1])


def wrapper_defs(func_name, func_type, args, fn):
    decl_arglist = ", ".join([" ".join(argrec) for argrec in args]) or "void"

    wrap = "extern %s z_impl_%s(%s);\n" % (func_type, func_name, decl_arglist)
    wrap += "\n"
    wrap += "__pinned_func\n"
    wrap += "static inline %s %s(%s)\n" % (func_type, func_name, decl_arglist)
    wrap += "{\n"

    # fall through to direct invocation of the impl func.
    impl_arglist = ", ".join([argrec[1] for argrec in args])
    impl_call = "z_impl_%s(%s)" % (func_name, impl_arglist)
    wrap += "\t" + "%s%s;\n" % ("return " if func_type != "void" else "",
                               impl_call)

    wrap += "}\n"

    return wrap

def analyze_fn(match_group, fn):
    func, args = match_group

    try:
        if args == "void":
            args = []
        else:
            args = [typename_split(a.strip()) for a in args.split(",")]

        func_type, func_name = typename_split(func)
    except SyscallParseException:
        sys.stderr.write("In declaration of %s\n" % func)
        raise

    invocation = wrapper_defs(func_name, func_type, args, fn)

    return invocation

def parse_args():
    global args
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("-i", "--json-file", required=True,
                        help="Read syscall information from json file")
    parser.add_argument("-l", "--syscall-list", required=True,
                        help="output C system call list header")
    parser.add_argument("-o", "--base-output", required=True,
                        help="Base output directory for syscall macro headers")
    args = parser.parse_args()

def main():
    parse_args()
    with open(args.json_file, 'r') as fd:
        syscalls = json.load(fd)

    invocations = {}
    mrsh_defs = {}
    mrsh_includes = {}
    ids = []
    table_entries = []
    handlers = []

    for match_group, fn, _ in syscalls:
        inv = analyze_fn(match_group, fn)

        if fn not in invocations:
            invocations[fn] = []

        invocations[fn].append(inv)

    os.makedirs(args.base_output, exist_ok=True)
    for fn, invo_list in invocations.items():
        out_fn = os.path.join(args.base_output, fn)

        ig = re.sub("[^a-zA-Z0-9]", "_", "Z_INCLUDE_SYSCALLS_" + fn).upper()
        include_guard = "#ifndef %s\n#define %s\n" % (ig, ig)
        header = syscall_template.format(include_guard=include_guard, invocations="\n\n".join(invo_list))

        with open(out_fn, "w") as fp:
            fp.write(header)

    # Syscalls are not supported in SDK, so just write dummy syscall definitions
    with open(args.syscall_list, "w") as fp:
        fp.write("/* Generated by gen_sdk_syscalls.py. Do not edit */\n")


if __name__ == "__main__":
    main()
